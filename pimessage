#!/usr/bin/python

"""
A messaging program between two Linux systems, optimized for the raspberry
pi running raspbian OS.

2014 Nate Fischer, Ivan De Dios

"""

import subprocess # for function calls
import os
import sys # for arg parsing
import string
import re # for searching
import time
import datetime
import mmap

## make sure indents are 4 spaces if possible
## vim settings:
##              set et
##              set ts=4

## perhaps an IPaddress class? This would mean changing some variable names


########################
##  Global constants  ##
########################

IP_FAILURE = 1
DIR_FAILURE = 2
NULL_ARGUMENT = "."

########################
##  Global variables  ##
########################

# values are listed here, but should not be uncommented
global hostIp
global operatingSystem

########################
##  Helper functions  ##
########################
def stringSlice(inString, searchString):
    # slices the input string so that the searchString is the beginning of
    # the returned string.  So if you pass in "hello world" as the first
    # string and then "lo" as the second string, this function will return
    # "lo world". If you pass in "foo" as the second string instead, you
    # will get "" returned. If you pass in "h" as the first string, you
    # will get "hello world" as the output.

    searchSub = inString.find(searchString)
    if searchSub == -1:
        returner = ""
    else:
        returner = inString[searchSub:]
    return returner



def mdUnix(name):
    if os.system("mkdir " + name) != 0:
        return DIR_FAILURE
    else:
        return 0

def initNewUser(user, homedir):
    print "Initializing new user"

    # make the directory
    if os.system("test -d " + homedir) != 0:
        if mdUnix(homedir) == DIR_FAILURE:
            exit(DIR_FAILURE)

    # generate user's keys
    # todo


    # Get user input
    # write info to files
    open(homedir+"editor", 'w').write("vim") # doesn't terminate in newline

    if os.system("test -d " + homedir + "conversations") != 0:
        if mdUnix(homedir + "conversations") == DIR_FAILURE:
            exit(DIR_FAILURE)
        else:
            # create permissions
            os.system("chmod 600 " + homedir + "conversations")


    open(homedir+"contacts", 'w').write("") # doesn't terminate in newline


    return 0

def grabOpt(argv, n):
    # returns the nth arg or returns NULL_ARGUMENT
    if len(argv) <= n:
        return NULL_ARGUMENT
    else:
        return argv[n]

def parseOpts(argv):
    scriptName = argv[0]
    secOpt = grabOpt(argv, 2)
    primOpt = grabOpt(argv, 1)

    if primOpt == NULL_ARGUMENT:
        # only contains the script name, no arguments
        # call usage function
        usage(scriptName)
        exit(1)


    if primOpt == "-h" or primOpt == "--help" or primOpt == "help":
        usage(scriptName)
        exit(0)
    elif primOpt == "ip": # show host IP address
        print hostIp # a global value

    elif primOpt == "history": # show recent chat history
        print("Under construction.")
        exit(3)
    elif primOpt == "new" or primOpt == "compose": # compose a message
        if secOpt == NULL_ARGUMENT:
            print "Invalid number of operands for %s option" % primOpt
            usage(scriptName)
            exit(1)

        #print "second option is", secOpt
        #print("Under construction.")
        #exit(3)
        sendMessage(secOpt)

    elif primOpt == "read": # read a conversation
        if secOpt == NULL_ARGUMENT:
            print "Invalid number of operands for %s option" % primOpt
            usage(scriptName)
            exit(1)

        print "second option is", secOpt
        print("Under construction.")
        exit(3)
    elif primOpt == "rm-convo": # delete a conversation
        if secOpt == NULL_ARGUMENT:
            print "Invalid number of operands for %s option" % primOpt
            usage(scriptName)
            exit(1)

        print "second option is", secOpt
        print("Under construction.")
        exit(3)
    elif primOpt == "resend": # resend a failed message
        if secOpt == NULL_ARGUMENT:
            print "Invalid number of operands for %s option" % primOpt
            usage(scriptName)
            exit(1)

        print "second option is", secOpt
        print("Under construction.")
        exit(3)


    elif primOpt == "contacts":
        # contacts of the form:
        # Adam Smith\t1.2.3.4
        # Betty Rogers\t98.76.54.321

        # Display the contact list in less
        if secOpt == "-a":
            # show IP addresses in output
            os.system("less "+dataDir+"contacts")
        else:
            # remove IP addresses from output
            os.system("sed 's/\t.*$//' " + dataDir+"contacts | less")

        exit(0)


    elif primOpt == "add":
        thirdOpt = grabOpt(argv, 3)

        if thirdOpt == NULL_ARGUMENT:
            print "Invalid number of operands for %s option" % primOpt
            usage(scriptName)
            exit(1)

        # default is to NOT overwrite (prompt user if they want to change)
        addContact(secOpt, thirdOpt, "n")


    elif primOpt == "force-link": 
        # force-link a contact to an IP
        # essentially, just overwrite a contact's IP

        thirdOpt = grabOpt(argv, 3)

        if thirdOpt == NULL_ARGUMENT:
            print "Invalid number of operands for %s option" % primOpt
            usage(scriptName)
            exit(1)

        # default is to overwrite old contact
        addContact(secOpt, thirdOpt, "y")


    elif primOpt == "rm-contact":
        if secOpt == NULL_ARGUMENT:
            print "Invalid number of operands for %s option" % primOpt
            usage(scriptName)
            exit(1)

        rmContact(secOpt)

    else:
        # some invalid option
        print "Invalid option %s" % primOpt
        usage(scriptName)
        exit(1)



########################
##  Option functions  ##
########################

def usage(scriptName):
    # Prints usage/help information
    # This is called by --help, -h, or invalid usage

    # print usage info
    print "Usage: %s [options] [option arguments]\n" % scriptName

    # print help/option info
    # Don't indent on docstring
    optionMsg = """Options:
help, -h, --help                           help
ip                                         show host IP address
history                                    show recent chat history
compose, new           CONTACT             compose & send message
read                   CONTACT             read a conversation
rm-convo               CONTACT             delete a conversation
resend                 CONTACT             resend a failed message
force-link             CONTACT, IP         force-link contact to IP
config                 VARIABLE, VALUE     configure varialbles
contacts               [-a]                view contact list [with IPs]
add                    CONTACT, IP         add a contact
rm-contact             CONTACT             delete a contact

"""

#-i , --show-ip                   Show your IP address
#-s , --history                   Show your recent chat history
#-c , --compose     CONTACT       Compose & send message
#-r , --read        CONTACT       Read a conversation
#-d , --delete      CONTACT       Delete a conversation
#-q , --resend      CONTACT       Resend a failed message
#-h , --help                      Help
#-f , --force-link  CONTACT, IP   Specify the IP address to try for CONTACT
#
#    """

    print(optionMsg)

    return # exit after calling this function


def getHostIp():
    # returns IP_FAILURE if no address was found

    ipaddress = IP_FAILURE # default case
    #cmdOutput = subprocess.Popen('ifconfig', stdout=subprocess.PIPE).communicate()[0]
    ##print cmdOutput


    ### slice the cmdOutput string:
    ##modifiedOutput = cmdOutput[inetsub:]
    #modifiedOutput = stringSlice(cmdOutput, "inet")
    #if (modifiedOutput == ""):
    #    return IP_FAILURE

    ## slice the cmdOutput string:
    #modifiedOutput = stringSlice(modifiedOutput, ":")
    #if (modifiedOutput == ""):
    #    return IP_FAILURE

    ### perhaps there is a good way to clean this up? ##
    #match_object = re.search('\d', modifiedOutput)
    #if match_object: # it returned a match
    #    startSub = match_object.start()
    #else:
    #    return IP_FAILURE

    #match_object = re.search(' ', modifiedOutput)
    #if match_object: # it returned a match
    #    endSub = match_object.start()
    #else:
    #    return IP_FAILURE

    #ipaddress = modifiedOutput[startSub:endSub-1]
    ipcmd = "wget -qO- icanhazip.com"
    ipaddress = subprocess.Popen(ipcmd.split(), stdout=subprocess.PIPE).communicate()[0]

    ipaddress = ipaddress.rstrip()


    return ipaddress # default is IP_FAILURE

def addContact(name, ip, overwrite):
    # Search for if this person is already there
    myFile = open(dataDir+"contacts", "r")
    allContacts = myFile.read()
    myFile.close()
    contactIndex = allContacts.find(name+"\t")
    if contactIndex != -1:
        if overwrite != "y":
            print "%s is already entered in your contact list." % name
            overwrite = raw_input("Would you like to overwrite this entry? (y/n) ")
        if overwrite != "y":
            print "Not overwriting the entry. Terminating."
            exit(1)
        else:
            # remove the old one
            rmContact(name)
            print "Your contact has been updated."


    # add contact normally
    myFile = open(dataDir+"contacts", "a")
    addString = name+"\t"+ip+"\n"
    myFile.write(addString)
    myFile.close()

    # use GNU sort
    sortCmd = "sort -f "+dataDir+"contacts > "+dataDir+"sort_contacts"
    os.system(sortCmd)

    # overwrite old file
    os.system("mv "+dataDir+"sort_contacts "+dataDir+"contacts")

    return 0

def rmContact(name):
    myFile = open(dataDir+"contacts", "r")
    allContacts = myFile.read()
    myFile.close()

    # this is the part up until that contact
    contactIndex = allContacts.find(name+"\t")
    if contactIndex == -1:
        # contact isn't in here
        return 1

    firstHalf = allContacts[0:contactIndex]

    # this is the part right after that contact until the end
    secondHalf = stringSlice(allContacts, name)
    secondHalf = stringSlice(secondHalf, '\n')
    secondHalf = secondHalf[1:]
    allContacts = firstHalf + secondHalf

    myFile = open(dataDir+"contacts", "w")
    myFile.write(allContacts) # add the new entry later
    myFile.close()



#    # Raspberry Pi logo
#    print(string.center("   .~~.   .~~.   ", width))
#    print(string.center("  '. \ ' ' / .'  ", width))
#    print(string.center("   .~ .~~~..~.   ", width))
#    print(string.center("  : .~.'~'.~. :  ", width))
#    print(string.center(" ~ (   ) (   ) ~ ", width))
#    print(string.center("( : '~'.~.'~' : )", width))
#    print(string.center(" ~ .~ (   ) ~. ~ ", width))
#    print(string.center("  (  : '~' :  )  ", width))
#    print(string.center("   '~ .~~~. ~'   ", width))
#    print(string.center("       '~'       ", width))
#    print("")
#
#    raw_input("Press enter to continue... ")
#    return 0



def sendMessage(myContact):
    # fetch sender IP
    if hostIp == IP_FAILURE:
        exit(1)

    # fetch recipient IP
    
    with open(dataDir+"contacts") as fp:
        for line in fp:
            rec = line.split('\t')
            if rec[0] == myContact:
                recIp = rec[1].rstrip('\n')
                break

    # compose the message

    # store this in conversations directory
    fileName = dataDir+"conversations/msg"+myContact

    # temporary editor vim
    editor = "vim" # DEBUG
    os.system(editor+" "+fileName)

    # prompt if they want to send or not
    shouldSend = raw_input("To send or not to send; that is the question (y/n): ")

    ss = shouldSend
    if ss != "y" and ss != "Y" and ss != "yes" and ss != "Yes" and ss != "YES":
        print "Your message has been saved for next time you compose a message to %s" % myContact
        exit(5)
    #if shouldSend != "eat me":
    #    exit(5)    
    #elif shouldSend != "y":
    #    exit(5)
    #elif shouldSend != "yes":
    #    exit(5)
    #elif shouldSend != "Yes":
    #    exit(5)
    #elif shouldSend != "YES":
    #    exit(5)

    # get time stamp in proper format
    sendTime = str(time.time())

    # format the message with the meta data
    message = open(fileName+'_'+sendTime, 'w')
    
    message.write(recIp+'\n')
    message.write(hostIp+'\n')    
    message.write(sendTime+"\n\n") # guaranteed two consecutive newlines

    with open(fileName) as fp:
        for line in fp:
           message.write(line)
    
    # clean up by removing old message to contact
    ret = os.system("rm "+fileName)
    if ret != 0:
        print "Error in removing message file."
        exit(2)
    
    # Send the full message
    #sploosh

    # add the message to conversation history
    
    return 0


########################
##   Main function    ##
########################

def main(argv):

    ## Get user information ##
    global operatingSystem
    operatingSystem = os.name
    if operatingSystem != "nt":
        operatingSystem = subprocess.Popen(['uname', '-s'], stdout=subprocess.PIPE).communicate()[0]
        operatingSystem = operatingSystem.rstrip('\n')
        # change Cygwin to say 'CYGWIN' always
        underScoreIndex = operatingSystem.find("_")
        if underScoreIndex != -1:
            operatingSystem = operatingSystem[:underScoreIndex]

    if operatingSystem != "Linux" and operatingSystem != "Darwin" and operatingSystem != "CYGWIN":
        print "Error: %s is not a supported operating system at this time." % operatingSystem
        exit(5)

    username = subprocess.Popen('whoami', stdout=subprocess.PIPE).communicate()[0]
    username = username.rstrip('\n') # removes trailing newline

    global dataDir
    dataDir = "/home/" + username + "/.pimessage/"
    dirExistsCommand = "test -d " + dataDir
    if os.system(dirExistsCommand) != 0:
        initNewUser(username, dataDir)

    dirFiles = subprocess.Popen(['ls', '-A', dataDir], stdout=subprocess.PIPE).communicate()[0]

    # must be in correct ls -A order
    CORRECT_DIR_FILES = """contacts
conversations
editor
"""

    if dirFiles != CORRECT_DIR_FILES:
        initNewUser(username, dataDir)

    # get user's chosen editor
    editCommand = open(dataDir+"editor", 'r').read()
    if subprocess.Popen(['which', editCommand], stdout=subprocess.PIPE).communicate()[0] == "":
        print "Error: %s is not a valid editor. Please adjust your editor value" % editCommand
        exit(2)

    global hostIp
    hostIp = getHostIp()
    if hostIp == IP_FAILURE:
        print "Error: your IP address could not be correctly retrieved."
        exit(2)

    # get number of rows and number of columns on terminal
    #screenRows, screenColumns = os.popen('stty size', 'r').read().split()
    #screenRows = int(screenRows)
    #screenColumns = int(screenColumns)


    ## User must already have information entered

    #keyPress = welcomeScreen(hostIp, screenColumns)



    ## Option parsing ##
    # figure out which option was called
    parseOpts(argv)









    return 0



if __name__ == "__main__":
    status = main(sys.argv)
    exit(status)
