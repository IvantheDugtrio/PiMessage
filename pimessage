#!/usr/bin/python

"""
A messaging program between two Linux systems, optimized for the raspberry
pi running raspbian OS.

2014 Nate Fischer, Ivan De Dios

"""

import subprocess # for function calls
import os
import sys # for arg parsing
import string
import re # for searching

## make sure indents are 4 spaces if possible
## vim settings:
##              set et
##              set ts=4

## perhaps an IPaddress class? This would mean changing some variable names


########################
##  Global constants  ##
########################

IP_FAILURE = 1
DIR_FAILURE = 2
NULL_ARGUMENT = "."

########################
##  Global variables  ##
########################

# values are listed here, but should not be uncommented
global hostIp
global operatingSystem

########################
##  Helper functions  ##
########################
def mdUnix(name):
    if os.system("mkdir " + name) != 0:
        return DIR_FAILURE
    else:
        return 0

def initNewUser(user, homedir):
    print "Initializing new user"

    # make the directory
    if os.system("test -d " + homedir) != 0:
        if mdUnix(homedir) == DIR_FAILURE:
            exit(DIR_FAILURE)

    # generate user's keys
    # todo


    # Get user input
    # write info to files
    open(homedir+"editor", 'w').write("vim") # doesn't terminate in newline

    if os.system("test -d " + homedir + "conversations") != 0:
        if mdUnix(homedir + "conversations") == DIR_FAILURE:
            exit(DIR_FAILURE)
        else:
            # create permissions
            os.system("chmod 600 " + homedir + "conversations")
    
    
    open(homedir+"contacts", 'w').write("") # doesn't terminate in newline


    return 0

def grabOpt(argv, n):
    # returns the nth arg or returns NULL_ARGUMENT
    if len(argv) <= n:
        return NULL_ARGUMENT
    else:
        return argv[n]

def parseOpts(argv):
    scriptName = argv[0]
    secOpt = grabOpt(argv, 2)
    primOpt = grabOpt(argv, 1)

    if primOpt == NULL_ARGUMENT:
        # only contains the script name, no arguments
        # call usage function
        usage(scriptName)
        exit(1)

    """
    Commands:                       | Options           | Arguments
     + help                         | help, -h, --help  | ---
     + show host IP address         | ip                | ---

     + show recent chat history     | history           | ---
     + compose & send message       | compose, new      | Name
     + read a conversation          | read              | Person's_Name
     + delete a conversation        | rm-convo          | Person's_Name
     + resend a failed message      | resend            | Person's_Name
     + force-link contact to IP     | force-link        | Person's_Name, IP
     + configure varialbles         | config            | varName, varValue

     + view contact list            | contacts          | ---
     + add a contact                | add               | Person's_Name, IP
     + delete a contact             | rm-contact        | Person's_Name
    """

    #           short opt           long opt
    if primOpt == "-h" or primOpt == "--help" or primOpt == "help":
        usage(scriptName)
        exit(0)
    elif primOpt == "ip": # show host IP address
        print hostIp # a global value

    elif primOpt == "history": # show recent chat history
        print("Under construction.")
        exit(3)
    elif primOpt == "new" or primOpt == "compose": # compose a message
        if secOpt == NULL_ARGUMENT:
            print "Invalid number of operands for %s option" % primOpt
            usage(scriptName)
            exit(1)

        print "second option is", secOpt
        print("Under construction.")
        exit(3)

    elif primOpt == "read": # read a conversation
        if secOpt == NULL_ARGUMENT:
            print "Invalid number of operands for %s option" % primOpt
            usage(scriptName)
            exit(1)

        print "second option is", secOpt
        print("Under construction.")
        exit(3)
    elif primOpt == "rm-convo": # delete a conversation
        if secOpt == NULL_ARGUMENT:
            print "Invalid number of operands for %s option" % primOpt
            usage(scriptName)
            exit(1)

        print "second option is", secOpt
        print("Under construction.")
        exit(3)
    elif primOpt == "resend": # resend a failed message
        if secOpt == NULL_ARGUMENT:
            print "Invalid number of operands for %s option" % primOpt
            usage(scriptName)
            exit(1)

        print "second option is", secOpt
        print("Under construction.")
        exit(3)
    elif primOpt == "force-link": # force-link a contact to an IP
        thirdOpt = grabOpt(argv, 3)

        if thirdOpt == NULL_ARGUMENT:
            print "Invalid number of operands for %s option" % primOpt
            usage(scriptName)
            exit(1)

        print "second option is", secOpt
        print "third option is", thirdOpt

        print("Under construction.")
        exit(3)
# for other options
    elif primOpt == "contacts":
        #print("Under construction.")
        print open(dataDir+"contacts", 'r').read()
        exit(0)
    elif primOpt == "add":
        if secOpt == NULL_ARGUMENT:
            print "Invalid number of operands for %s option" % primOpt
            usage(scriptName)
            exit(1)

        print "second option is", secOpt
        print("Under construction.")
        exit(3)
    elif primOpt == "rm-contact":
        if secOpt == NULL_ARGUMENT:
            print "Invalid number of operands for %s option" % primOpt
            usage(scriptName)
            exit(1)

        print "second option is", secOpt
        print("Under construction.")
        exit(3)
    else:
        # some invalid option
        print "Invalid option %s" % primOpt
        usage(scriptName)
        exit(1)



########################
##  Option functions  ##
########################

def usage(scriptName):
    # Prints usage/help information
    # This is called by --help, -h, or invalid usage

    # print usage info
    print "Usage: %s [options] [option arguments]\n" % scriptName

    # print help/option info
    # Don't indent on docstring
    optionMsg = """Options:
help, -h, --help                           help
show                                       show host IP address
history                                    show recent chat history
compose, new           CONTACT             compose & send message
read                   CONTACT             read a conversation
rm-convo               CONTACT             delete a conversation
resend                 CONTACT             resend a failed message
force-link             CONTACT, IP         force-link contact to IP
config                 variable, value     configure varialbles
contacts                                   view contact list
add                    CONTACT, IP         add a contact
rm-contact             CONTACT             delete a contact

"""

#-i , --show-ip                   Show your IP address
#-s , --history                   Show your recent chat history
#-c , --compose     CONTACT       Compose & send message
#-r , --read        CONTACT       Read a conversation
#-d , --delete      CONTACT       Delete a conversation
#-q , --resend      CONTACT       Resend a failed message
#-h , --help                      Help
#-f , --force-link  CONTACT, IP   Specify the IP address to try for CONTACT
#
#    """

    print(optionMsg)

    return # exit after calling this function


def getHostIp():
    # returns IP_FAILURE if no address was found

    ipaddress = IP_FAILURE # default case
    cmdOutput = subprocess.Popen('ifconfig', stdout=subprocess.PIPE).communicate()[0]
    #print cmdOutput


    inetsub = cmdOutput.find("inet")
    if (inetsub == -1): # not connected to internet
        return IP_FAILURE

    # slice the cmdOutput string:
    modifiedOutput = cmdOutput[inetsub:]

    colonsub = modifiedOutput.find(':')
    if (colonsub == -1): # not connected to internet
        return IP_FAILURE

    # slice the cmdOutput string:
    modifiedOutput = modifiedOutput[colonsub+1:]

    ## perhaps there is a good way to clean this up? ##
    match_object = re.search('\d', modifiedOutput)
    if match_object: # it returned a match
        startSub = match_object.start()
    else:
        return IP_FAILURE

    match_object = re.search(' ', modifiedOutput)
    if match_object: # it returned a match
        endSub = match_object.start()
    else:
        return IP_FAILURE

    ipaddress = modifiedOutput[startSub:endSub-1]
    return ipaddress # default is IP_FAILURE


#def welcomeScreen(ip, width):
#    # clear screen
#    os.system('clear')
#
#    print(string.center("Welcome to piMessage", width))
#    print("")
#
#    # Raspberry Pi logo
#    print(string.center("   .~~.   .~~.   ", width))
#    print(string.center("  '. \ ' ' / .'  ", width))
#    print(string.center("   .~ .~~~..~.   ", width))
#    print(string.center("  : .~.'~'.~. :  ", width))
#    print(string.center(" ~ (   ) (   ) ~ ", width))
#    print(string.center("( : '~'.~.'~' : )", width))
#    print(string.center(" ~ .~ (   ) ~. ~ ", width))
#    print(string.center("  (  : '~' :  )  ", width))
#    print(string.center("   '~ .~~~. ~'   ", width))
#    print(string.center("       '~'       ", width))
#    print("")
#
#    ipString = "Your IP Address is: "+ip
#    print(ipString.center(width))
#    print(string.center("To connect to a friend, exchange IP addresses with them.", width))
#
#    print("")
#    raw_input("Press enter to continue... ")
#    return 0



def sendMessage(myContact):
    # todo
    return 0


########################
##   Main function    ##
########################

def main(argv):

    ## Get user information ##
    global operatingSystem
    operatingSystem = os.name
    if operatingSystem != "nt":
        operatingSystem = subprocess.Popen(['uname', '-s'], stdout=subprocess.PIPE).communicate()[0]
        operatingSystem = operatingSystem.rstrip('\n')

    if operatingSystem != "Linux" and operatingSystem != "Darwin":
        print "Error: %s is not a supported operating system at this time." % operatingSystem
        exit(5)

    username = subprocess.Popen('whoami', stdout=subprocess.PIPE).communicate()[0]
    username = username.rstrip('\n') # removes trailing newline

    global dataDir
    dataDir = "/home/" + username + "/.pimessage/"
    dirExistsCommand = "test -d " + dataDir
    if os.system(dirExistsCommand) != 0:
        initNewUser(username, dataDir)

    dirFiles = subprocess.Popen(['ls', '-A', dataDir], stdout=subprocess.PIPE).communicate()[0]

    # must be in correct ls -A order
    CORRECT_DIR_FILES = """contacts
conversations
editor
"""

    if dirFiles != CORRECT_DIR_FILES:
        initNewUser(username, dataDir)

    # get user's chosen editor
    editCommand = open(dataDir+"editor", 'r').read()
    if subprocess.Popen(['which', editCommand], stdout=subprocess.PIPE).communicate()[0] == "":
        print "Error: %s is not a valid editor. Please adjust your editor value" % editCommand
        exit(2)

    global hostIp
    hostIp = getHostIp()
    if hostIp == IP_FAILURE:
        print "Error: your IP address could not be correctly retrieved."
        exit(2)

    # get number of rows and number of columns on terminal
    #screenRows, screenColumns = os.popen('stty size', 'r').read().split()
    #screenRows = int(screenRows)
    #screenColumns = int(screenColumns)


    ## User must already have information entered

    #keyPress = welcomeScreen(hostIp, screenColumns)



    ## Option parsing ##
    # figure out which option was called
    parseOpts(argv)









    return 0



if __name__ == "__main__":
    status = main(sys.argv)
    exit(status)
